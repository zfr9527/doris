// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

#pragma once

#include "exec/exec_node.h"
#include "exprs/runtime_filter.h"

namespace doris::vectorized {

class VScanner;
class VScanNode : public ExecNode {
public:
    Status init(const TPlanNode &tnode, RuntimeState *state = nullptr) override;

    Status prepare(RuntimeState *state) override;

    Status open(RuntimeState *state) override;

    Status get_next(RuntimeState *state, RowBatch *row_batch, bool *eos) override {
        return Status::NotSupported("Not implement");
    }

    Status get_next(RuntimeState *state, vectorized::Block *block, bool *eos) override;

    Status close(RuntimeState *state) override;

    enum PushdownType {
        REJECT, // the predicate can not pushdown to the data source
        FULL,   // the predicate can be pushdown to data source, and data source can fully handle it.
        PARTIAL // the predicate can be pushdown to data source, but it still need to be kept in conjuncts.
    };

protected:

    // Different data sources register different profiles by implementing this method
    virtual Status _init_profile() {
        return Status::OK();
    }

    // Process predicates, extract the predicates in the conjuncts that can be pushed down
    // to the data source, and convert them into common expressions structure ColumnPredicate.
    // There are currently 3 types of predicates that can be pushed down to data sources:
    //
    // 1. Simple predicate, with column on left and constant on right, such as "a=1", "b in (1,2,3)" etc.
    // 2. Bloom Filter, predicate condition generated by runtime filter
    // 3. Function Filter, some data sources can accept function conditions, such as "a like 'abc%'"
    //
    // Predicates that can be fully processed by the data source will be removed from conjuncts
    Status _process_conjuncts() {
        return Status::OK();
    }

    // Create a set of scanners.
    // The number of scanners is related to the implementation of the data source, predicate conditions, and scheduling strategy.
    // So this method needs to be implemented separately by the subclass of ScanNode.
    // Finally, a set of scanners that have been prepared are returned.
    Status _init_scanners();

    // Submit the scanner to the thread pool and start execution
    Status _start_scanners();

    // Different data sources can implement this method to determine whether a predicate
    // can be processed by the data source
    virtual PushdownType _is_conjuncts_acceptable(ExprContext *ctx) {
        return PushdownType::REJECT;
    }

protected:

    // conjuncts from sql directly
    // the conjuncts vector may contain direct conjunct and runtime filter conjunct.
    int _direct_conjunct_size;
    int _max_scan_key_num;
    int _max_pushdown_conditions_per_column;
    int64_t _max_scanner_queue_size_bytes;

    // For runtime filters
    struct RuntimeFilterContext {
        RuntimeFilterContext() : apply_mark(false), runtime_filter(nullptr) {}

        bool apply_mark;
        IRuntimeFilter *runtime_filter;
    };

    std::vector<TRuntimeFilterDesc> _runtime_filter_descs;
    std::vector<RuntimeFilterContext> _runtime_filter_ctxs;
    // set to true if the runtime filter is ready.
    std::vector<bool> _runtime_filter_ready_flag;
    std::vector<std::unique_ptr<std::mutex>> _rf_locks;
    std::map<int, RuntimeFilterContext*> _conjunct_id_to_runtime_filter_ctxs;

    RuntimeState* _runtime_state;

    SpinLock _status_mutex;
    Status _process_status;
    std::atomic<bool> _scan_finished;
    int _num_running_scanners;

    // for blocks queue
    std::mutex _queue_lock;
    std::condition_variable _queue_reader_cond;
    std::condition_variable _queue_writer_cond;
    std::deque<Block*> _block_queue;
    std::unique_ptr<MutableBlock> _mutable_block;

    std::mutex _free_blocks_lock;
    std::vector<Block*> _free_blocks;

    int _running_thread = 0;
    int64_t _scan_row_batches_bytes = 0;
    std::condition_variable _scan_thread_exit_cv;

    std::mutex _scanners_lock;
    std::list<VScanner*> _scanners;

    int _block_per_scanner;
    TupleDescriptor* _tuple_desc;

private:
    Status _register_runtime_filter();

    Status _acquire_runtime_filter();

    bool update_status(const Status& new_status) {
        if (_process_status.ok()) {
            _process_status = new_status;
            return true;
        }
        return false;
    }

    void scanner_thread(VScanner* scanner);

    Block* _alloc_block(bool* get_free_block);

    Status _submit_scanner(RuntimeState* state, ThreadPoolToken* thread_token,
            PriorityThreadPool* thread_pool,
            PriorityThreadPool* remote_thread_pool, VScanner* scanner,
            const OpentelemetrySpan& cur_span);
};

} // namespace doris::vectorized
